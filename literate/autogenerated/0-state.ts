// AUTOGENERATED
// The original file is literate/0-state.md

// PLEASE DO NOT EDIT THIS FILE DIRECTLY !


export function isObject(value: unknown): value is object {
  return value !== null && typeof value === 'object';
}

export function shallowCloneObject(value: object): object {
  if (Array.isArray(value)) return value.slice(0);
  return Object.assign({}, value);
}

export type ObjectCache = Map<object, object>;

export function createProxyCached(frozen: object, proxies: ObjectCache) {
  if (!proxies.has(frozen)) {
    proxies.set(frozen, createProxy(frozen, proxies));
  }
  return proxies.get(frozen)!;
}

export const unchanged = Symbol('unchanged');

export function createProxy(frozen: object, proxies: ObjectCache) {
  let clone = shallowCloneObject(frozen);
  clone[unchanged] = frozen;

  return new Proxy(clone, {
    setPrototypeOf: () => false, // Disallow prototype

    // Write traps:
    set: function (target) {
      target[unchanged] = false;
      // @ts-ignore: next-line
      return Reflect.set(...arguments);
    },
    deleteProperty: function (target) {
      target[unchanged] = false;
      // @ts-ignore: next-line
      return Reflect.deleteProperty(...arguments);
    },

    // Read trap:
    get: function (target, p) {
      if (p === unchanged) return target[p];
      if (target[p] !== frozen[p]) return target[p];
      // Functions are still returned frozen
      if (!isObject(target[p])) return target[p];
      return createProxyCached(frozen[p], proxies);
    },
  });
}

export function normalizeUnchangedMarker(root: object) {
  const changedDirectly = new Set<object>();
  const stopIterating = new Set();
  // One object can have many parents
  const childToParents = new Map<object, object[]>();

  (function fillMappings(val: object) {
    if (val && !val[unchanged]) changedDirectly.add(val);
    stopIterating.add(val);

    for (var p in val) {
      let child = val[p];
      if (!isUnfrozenObject(child)) continue;
      // Fill parent map
      if (!childToParents.has(child)) childToParents.set(child, []);
      childToParents.get(child)!.push(val);
      // Recurse
      if (!stopIterating.has(child)) fillMappings(child);
    }
  })(root);

  function normalizeIterateParents(changed: object) {
    let parents = childToParents.get(changed) || [];
    for (let parent of parents) {
      if (!parent[unchanged]) continue;
      parent[unchanged] = false;
      normalizeIterateParents(parent);
    }
  }
  changedDirectly.forEach(normalizeIterateParents);
}

export const frozen = Symbol('frozen');

export function isUnfrozenObject(val: unknown): val is object {
  return isObject(val) && !val[frozen];
}

export function freeze(root: unknown) {
  if (!isObject(root)) return Object.freeze(root);
  normalizeUnchangedMarker(root);
  const cloneCache = new Map();
  const result = cloneChanged(root, cloneCache);

  cloneCache.forEach(obj => {
    obj[frozen] = true;
    Object.freeze(obj);
  });
  return result;
}

export function cloneChanged(val: unknown, cloneCache: ObjectCache) {
  // Simple Cases - No cloning needed
  if (typeof val === 'function') return Object.freeze(val);
  if (!isUnfrozenObject(val)) return val;
  if (val[unchanged]) return val[unchanged];
  if (val instanceof Date) return val.toISOString();
  if (cloneCache.has(val)) return cloneCache.get(val);

  // Clone and recurse
  const cloned = shallowCloneObject(val);
  cloneCache.set(val, cloned);
  for (var prop in cloned) {
    cloned[prop] = cloneChanged(cloned[prop], cloneCache);
  }
  return cloned;
}

export abstract class StateMinimal {
  __frozen = freeze({});

  rootProp = (prop: string) => this.__frozen[prop];
  rootUpdate(action: (data: object) => void): void {
    const root = createProxyCached(this.__frozen, new Map());
    action(root);
    this.__frozen = freeze(root);
    this.onChange();
  }
  abstract onChange(): void;
}

export type Computable = (state: State) => unknown;
export type ComputableObj = { [prop: string]: Computable };

export function deriveComputable(state: State, comp: ComputableObj): State {
  let derived = Object.create(state);
  let isRunning = false; // Stops infinite recursion issues

  let cacheFrozen = null;
  let cacheComputed = new Map<Computable, unknown>();

  derived.rootProp = function (prop: string) {
    let func = comp[prop];
    if (!func) return state.rootProp(prop);
    // This is enough, since rootProps aren't cached no top level cache invalidation is needed
    if (cacheFrozen !== state.__frozen) cacheComputed.clear();
    if (cacheComputed.has(func)) return cacheComputed.get(func);
    if (isRunning) return undefined;
    let result: unknown = undefined;
    try {
      isRunning = true;
      result = freeze(func(this));
    } catch (e) {
      console.error(e);
    } finally {
      isRunning = false;
      cacheComputed.set(func, result);
    }
    return result;
  };
  return derived;
}

export const isArrayProp = (prop: any) => +prop >= 0;

export function getExpectedObject(val: unknown, isArray: boolean) {
  if (val === null || val === undefined) return isArray ? [] : {};
  if (!isUnfrozenObject(val)) return false;
  if (Array.isArray(val) !== isArray) return false;
  return val;
}

export type PathSection = { p: string; ref?: true };
export type Path = { get: () => unknown; write: () => WriteCtx };
export type WriteCtx = { parent: object; prop: string | number };

export function parsePath(input: string): PathSection[] {
  return input.split('/').map(p => {
    if (!p.startsWith(':')) return { p };
    return { p: p.substring(1), ref: true };
  });
}

export function parse(path: string, cache: Map<string, Path>): Path {
  if (!cache.has(path)) {
    let sections = parsePath(path);
    cache.set(path, {
      get: compileCachedGetter(sections),
      write: compileWriter(sections),
    });
  }
  return cache.get(path)!;
}

export function compileCachedGetter(path: PathSection[]) {
  // TODO 3 - actually compile
  return () => undefined;
}

export function compileWriter(path: PathSection[], from?: WriteCtx) {
  return () => ({ parent: {}, prop: 123 });
}

export class State extends StateMinimal {
  __cachePaths = new Map<string, Path>();

  watchers = new Set<Function>();

  get(path: string) {}
  set(path: string, value: unknown) {}
  update(path: string, action: (data: object) => void) {}
  onChange() {}
}