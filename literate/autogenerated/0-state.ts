// AUTOGENERATED
// The original file is literate/0-state.md

// PLEASE DO NOT EDIT THIS FILE DIRECTLY !


function isObject(value: unknown): value is object {
  return value !== null && typeof value === 'object';
}

function shallowCloneObject(value: object): object {
  if (Array.isArray(value)) return value.slice(0);
  return Object.assign({}, value);
}

class Cache<V> extends Map<any, V> {
  caching(key: any, creator?: (setCache: (V) => void) => void): V | undefined {
    if (!this.has(key) && creator) {
      // Stops infinite recursion issues
      this.set(key, undefined as V);
      // Create cache entry
      creator(c => this.set(key, c));
    }
    return this.get(key);
  }
}

const unchanged = Symbol('unchanged');

function createProxy(frozen: object, cache: Cache<object>) {
  return cache.caching(frozen, setCache => {
    const clone = shallowCloneObject(frozen);
    clone[unchanged] = frozen;

    const proxy = new Proxy(clone, {
      setPrototypeOf: () => false, // Disallow prototype

      // Write traps:
      set: function (target) {
        target[unchanged] = false;
        // @ts-ignore: next-line
        return Reflect.set(...arguments);
      },
      deleteProperty: function (target) {
        target[unchanged] = false;
        // @ts-ignore: next-line
        return Reflect.deleteProperty(...arguments);
      },

      // Read trap:
      get: function (target, p) {
        if (p === unchanged) return target[p];
        if (target[p] !== frozen[p]) return target[p];
        // Functions are still returned frozen
        if (!isObject(target[p])) return target[p];
        return createProxy(frozen[p], cache);
      },
    });
    setCache(proxy);
  });
}

function normalizeUnchangedMarker(root: object) {
  const changedDirectly = new Set<object>();
  const stopIterating = new Set();
  // One object can have many parents
  const childToParents = new Map<object, object[]>();

  (function fillMappings(val: object) {
    if (val && !val[unchanged]) changedDirectly.add(val);
    stopIterating.add(val);

    for (var p in val) {
      let child = val[p];
      if (!isUnfrozenObject(child)) continue;
      // Fill parent map
      if (!childToParents.has(child)) childToParents.set(child, []);
      childToParents.get(child)!.push(val);
      // Recurse
      if (!stopIterating.has(child)) fillMappings(child);
    }
  })(root);

  function normalizeIterateParents(changed: object) {
    let parents = childToParents.get(changed) || [];
    for (let parent of parents) {
      if (!parent[unchanged]) continue;
      parent[unchanged] = false;
      normalizeIterateParents(parent);
    }
  }
  changedDirectly.forEach(normalizeIterateParents);
}

const frozen = Symbol('frozen');

function isUnfrozenObject(val: unknown): val is object {
  return isObject(val) && !val[frozen];
}

function freeze(root: unknown) {
  if (!isObject(root)) return Object.freeze(root);
  normalizeUnchangedMarker(root);
  const cloneCache = new Cache<object>();
  const result = cloneChanged(root, cloneCache);

  cloneCache.forEach(obj => {
    obj[frozen] = true;
    Object.freeze(obj);
  });
  return result;
}

function cloneChanged(val: unknown, cache: Cache<object>) {
  // Simple Cases - No cloning needed
  if (typeof val === 'function') return Object.freeze(val);
  if (!isUnfrozenObject(val)) return val;
  if (val[unchanged]) return val[unchanged];
  if (val instanceof Date) return val.toISOString();

  // Clone and recurse
  return cache.caching(val, setCache => {
    const cloned = shallowCloneObject(val);
    setCache(cloned);

    for (var prop in cloned) {
      cloned[prop] = cloneChanged(cloned[prop], cache);
    }
  });
}

abstract class StateMinimal {
  __frozen = freeze({});

  root = (prop: string) => this.__frozen[prop];
  update(action: (data: object) => void): void {
    const root = createProxy(this.__frozen, new Cache());
    action(root!);
    this.__frozen = freeze(root);
    this.onChange();
  }
  abstract onChange(): void;
}

export class State extends StateMinimal {
  __cacheGet = new Cache<Get>();

  get(path: string) {
    return createGet(path, this.__cacheGet)(this);
  }
  set(path: string, value: unknown) {
    this.update(path, ({ parent, key }) => (parent[prop] = value));
  }
  map(path: string, action: (ctx: WriteCtx) => void) {
    this.update(data => action(initialize(path, data)));
  }
  onChange() {
    __cacheGet.clear();
  }
}

type Computable = (state: State) => unknown;
type ComputableObj = { [prop: string]: Computable };

export function computed(state: State, comp: ComputableObj): State {
  let cacheResult = new Cache<unknown>();
  let cacheFrozen = null;

  // root(...) is not cached so no other cache invalidation is needed
  function clearCache() {
    cacheResult.clear();
    cacheFrozen = state.__frozen;
  }

  function root(prop: string) {
    const that = this;
    if (!comp[prop]) return state.root(prop);
    if (cacheFrozen !== state.__frozen) clearCache();

    return cacheResult.caching(comp[prop], setCache => {
      try {
        setCache(freeze(comp[prop](that)));
      } catch (e) {
        console.error(e);
      }
    });
  }
  return Object.setPrototypeOf({ root }, state);
}

const isArrayProp = (prop: any) => +prop >= 0;

function getExpectedObject(val: unknown, isArray: boolean) {
  if (val === null || val === undefined) return isArray ? [] : {};
  if (!isUnfrozenObject(val)) return false;
  if (Array.isArray(val) !== isArray) return false;
  return val;
}

type Segment = { p: string; ref?: true };
type WriteCtx = { parent: object; prop: string | number };
type Getter = () => unknown;
type Writer = () => WriteCtx;

function parsePath(input: string): Segment[] {
  // TODO 2 - cache!
  function section(p) {
    return p.startsWith(':') ? { p: p.substring(1), ref: true } : { p };
  }
  return input.split('/').map(section);
}

function createGetter(path: string, cache: Cache<Getter>): Getter {
  return cache.caching(path, setCache => {
    let segments = parsePath(path);
    // TODO 1 - actually compile
  });
}

function createBuilder(path: string, from?: WriteCtx): WriteCtx {
  let segments = parsePath(path);
  return () => ({ parent: {}, prop: 123 });
}