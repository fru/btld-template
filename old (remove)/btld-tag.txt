Worksheet Version 1


Parsing: html with paths
* Outer Attribute: $test=”...”
* Outer Placeholder: ${...}
* Inner Path:
   * test
   * form1/values
   * values/123
   * values/:test/checked
   * values/length


var a1 = '<div $test="test"></div>';
var a2 = '<div $test="form1/values"></div>';
var a3 = '<div $test="values/123"></div>';
var a4 = '<div $test="values/:test/checked"></div>';
var a5 = '<div $test="values/length"></div>';


var b1 = '<div test="Test ${test}"></div>';
var b2 = '<div test="Test ${form1/values}"></div>';
var b3 = '<div test="Test ${values/123}"></div>';
var b4 = '<div test="Test ${values/:test/checked}"></div>';
var b5 = '<div test="Test ${values/length}"></div>';


var c1 = '<div test="123">Test ${test} <br></div>';
var c2 = '<div test="123">Test ${form1/values} <br></div>';
var c3 = '<div test="123">Test ${values/123} <br></div>';
var c4 = '<div test="123">Test ${values/:test/checked} <br></div>';
var c5 = '<div test="123">Test ${values/length} <br></div>';
 


Parsing: AST


* Types: Element, Attribute, Content, Expression


var exp3 = {p: ['values', 123]};
var exp4 = {p: ['values', {ref: 'test'}, 'checked']};


var attr_b3 = {test: ['Test ', exp3]};
var parsed_b3 = [{el: 'div', a: attr_h3, i: []}];
var inner_c3 = ['Test ', exp3, ' ', {el: 'br'}];
var parsed_c3 = [{el: 'div', a: {test: '123'}, i: inner_c3}];


var parsed_a4 = [{el: 'div', a: {test: exp4} }];



Property binding


* <attr name=”xyz” />
* <data name=”xyz” />
* Mixins like “form” can add local state like “validation”
* Mixins like “repeat” can add template state like “item” or “index”
* Mixins like “repeat” can add template state with a configurable name on the initial mixin run (first build) like: “special-item-1”
* A specific or implicit context




* Attibute changes affect properties
* Local data is stored in a fancy property: _state
* Template state like “item” have to depend on properties




* Only update component when a property changes
* Property changes are applied synchronously ??
* Any listener of a property has an order integer and can specify an array of paths that are checked for equality before execution
* This is all to reduce the number of dom updates
* Problem: The  array of paths that are checked - the path can depend on other properties eg: form1/:name/value






Open Problems


* Any mixin like ‘$bind’ does not produce a bind attribute by default. The mixin needs to explicitly create the attribute - how would the mixin do that?
* The implicit context property. Is there a shorthand for context/form1/fields: /form1/fields        //from1/fields           ~/form1/fields
* Every template mixin is called twice: once normal, second in a fallback mode if there is no other content. How is the syntax?
* Every template can produce a dom array. The template mixins can then manipulate the array. The component makes sure the arrays are stitched together and the dom is kept in sync. How can this be done efficiently? Syntax?
* There needs to be a translation mixin with strings coming from other custom js or ajax etc.




Context


var context1 = new BtldContext();
var sub0 = context1.sub(['v']);
var sub1 = sub0.sub([1, 'a']);
var listen1 = sinon.spy((v) => console.log('Root: ' + v));
var listen2 = sinon.spy((v) => console.log('Val: ' + v));
context1.listen('v', listen1)
sub1.listen('test', listen2)
sub1.set([], {test: 123});


sub1.get(['test']) === 123;
context1.get(['v', 1, 'a', 'test']) === 123;
context1.get(['v', 1, 'a']) === Object.isFrozen() === {test: 123};


listen1.should.have.been.calledWith([undefined, {a: {test: 123}} ]);
listen2.should.have.been.calledWith(123);


context.set(['v'], {'123': 'b'});
listen1.should.have.been.calledWith({'123': 'b'});
listen2.should.have.been.calledWith(undefined);


listen1.should.have.been.calledTwice();
listen2.should.have.been.calledTwice();


context.get() === {v: {'123': 'b'}};
context.set(['v', 1], 'b');
context.get() === {v: [undefined, 'b']};



Syntax - HTML


<btld-tag name="btld-input">
        <mixin>form</mixin>
        <mixin>format-date</mixin>


        <attr name="data" type="json" />
        <attr name="filter" type="range-number" />
        <attr name="dates" type="range-dates" />


        <template>
            <input type="checkbox" $bind-array="form1/values" value="text" />
            <input type="checkbox" $bind=":value/checked" value="text" />


            <input type="radio" $bind="gender" value="D" />
            <input type="radio" $bind="gender" $value="enum1/D" />


            <span format-date="YYYY-MM-D">${date1}</span>
            <span format-date="YYYY-MM-D" abc="${date1}"></span>
            <span format-date="YYYY-MM-D" $abc="date1"></span>


            <a href="/test/${abc}/index.html">Test</a>


            <div $ref="div1"></div>
            <div ref="${div1}"></div>
        </template>


        <template $repeat="addresses" as="addr">


        </template>
        <template $empty="addresses">


        </template>
        <template fallback></template>
</btld-tag>



Syntax - JS


btld.tag('btld-input', [
{el: 'mixin', i: ['form']}, ...
]);
btld.context.set({test: 123})
btld.render('btld-input', thisElement)



Errors Parsing


* “<div $test="test@"></div>” -  
* “<div test="${test@}"></div>” -  




Initial Render


let newDiv = document.createElement("div");
let newContent = document.createTextNode("Hi there and greetings!");
newDiv.appendChild(newContent);
newDiv.remove();
newContent.textContent = "I have changed!";
newDiv.setAttribute("name", "helloButton");
newDiv.removeAttribute('test')

https://stackoverflow.com/questions/5525795/does-javascript-guarantee-object-property-order


const isFileInput = (el) => el.type === 'file';
const isCheckInput = (el) => el.type === 'radio' || el.type === 'checkbox';


btld.tagMixins.bind = () => {
        const data = this.parseAttr();
        const read = (el) => {
                if (isFileInput(el)) return el.files;
                return isCheckInput(el) ? el.checked : el.value;
        };
this.addEventListener('change', (ev) => data.set(read(ev.target)));
data.bind(value => {
                if (isFileInput(el)) el.files = value;
else if (isCheckInput(el)) el.checked = value;
else el.value = value;
});
};

this for mixins === custom element???


$ctx=”ctx” as default


template -> templateRender ([root node], [{attributesBindings} + update node])


Html In -> Call render -> Test Html        WebTestRunner




List of templates  ->  Apply mixins (or default): add local vars, call builder create and attach or detach + (optionally wrap) -> Easy ;-) 


TODO Attach result coherently to the dom


Interoperability: Context


TODO: Interface of context, does one need to watch for dom mutation???, how is the context passed down, use of default context value
TODO: when and how to restrict (drill down) into the context?
TODO: btld-tag  > other-tag >> btld-tag how to ensure proper context propagation - and not multiple cascades of context propagation


=> Context is only passed into shadow dom. Every custom tag in shadow dom get property context set by :root element. 




Interoperability: Styling


TODO: Just like the context a style url can be passed down into every component of a certain type - use prefix? E.g: csb- rsb-




Global Default Mixins


One default mixin is used to implement the interoperable context spec 


btld.tagMixinsExtendable.context = () => {
        // Pass context to every child element
};
btld.tagMixinsGlobal.push('context');



Only one type of mixin: Attribute. Root tags like template, data, attr gain functionality by default mixins??? 










Glob
Use glob expressions like *-fields or format-* to apply element specific style sheets and also to select attributes




el1.closest(‘:root’)




Rendering
VDOM
The vdom is created from the definition json, it contains the dom nodes, dom event listeners and dom properties. Mixins from the definition are used to modify the vdom. These modifications are done during the initial render or later when mixins bind to an event. There is no mixin definition left in the vdom. 


Two classes with hidden state make up the VDOM. These are BtldNode and BtldFlatArray. Both can be hidden using that property but once created they can never be removed from the vdom. But they can be moved.


Both have properties to store the expected syncronzation with actual dom. If an element syncronizedAttr is falsy then the parent also needs that property to be falsy. When setting these properties to false the values have to be cascaded until a parent has that property allready falsy.


The custom component has a method to render the vdom into dom.


export class BtldVdomElement {
        detachedByMixin: {[mixin: string]: boolean} = {};
        synchromize: boolean?;
}


export class BtldVdomListener {
        synchromize: boolean?;
}


export class BtldVdomAttribute {
        synchromize: boolean?;
}


export class BtldVdomText {


}


export class BtldVdomNode {
        listeners: BtldVdomListener[] = [];
        attributes: {[attr: string]: BtldVdomAttribute} = {};
        localValues: {[variable: string]: any;
        // how to bind to locals ?
}


export class BtldVdomFlatArray {
        move(from, to)
        add(definition)
} 



  
Mixins 
$repeat


function createArrayDiff(values, previous) {
const deleted = [], moved = [], added = [], previousCopy = [];


for (const [index, item] of previous.entries()) {
        if (values.contains(item)) {
                previousCopy.push(item)
} else {
        deleted.push({index, item});
}
}


for (const [index, item] of values.entries()) {
        let oldIndex = previousCopy.indexOf(item);
        if (oldIndex === -1) {
                added.push({index, item});
} else if (oldIndex !== index) {
        moved.push({from: oldIndex, to: index});
        previousCopy.splice(oldIndex, 1);
}
previousCopy.splice(index, 0, item);
}
        return {deleted, moved, added};
}


btld.tagMixins['repeat'] = [ORDER_RENDER, (root, element, dom) => {
element.bindAttr('repeat', (value, previous) => {
        const {deleted, moved, added} = createArrayDiff(value, previous);
                for (let {index} of deleted) builder.detach(index);
                for (let {from, to} of moved) builder.move(from, to);
                for (let {index, item} of added) builder.add(index, item);
});
}];



$repeat-sort
Can be used with $repeat to sort the items




$i18n
This mixin is capable of iterating DOM, can find i18n-key=”” or even dynamic $i18n-key values. It can asynchronously replace template content / DOM and even add new expressions after the first render phase. 






$bind






$format-currency






$format-null






$context






$form-validation-summary






$if


btld.tagMixins['if'] = [ORDER_CLEAR, (root, element, dom) => {
        element.assertRootChild(true);
        element.bindAttr('if', value => dom.hideViaMixin('if', !value));
}];



$else
This mixin can be used to render only if there is no previous content 


btld.tagMixins['else'] = [ORDER_CLEAR, (definition, vdom) => {
        definition.assertIsRootChild();
vdom.bindNodes(nodes => vdom.hideViaMixin('else', hasPrevious(nodes)));


        function hasPrevious(nodes) {
return vdom.hasVisibleNodes(nodes.slice(0, definition.getIndex()));
}
}];



$dynamic-tag
Use a different tag on this element


btld.tagMixins['dynamic-tag'] = [ORDER_CLEAR, (definition, vdom) => {
        definition.assertIsContentChild();
        definition.bindAttr('dynamic-tag', tag => replaceTag(tag, vdom.node));


        function replaceTag(tag, oldEl) {
                if (!tag || tag.toUpperCase() === oldEl.tagName) return;
                
var newEl = document.createElement(tag);
                newEl.append(...oldEl.childNodes);
                dom.replace(oldEl, newEl);


                dom.updateAttributes();
                dom.updateListeners();
// We should not need to replace old bindings - since dom.node was updated
}
}];



$required
This mixin is used to validate form elements, this might need to access the $bind path for validation. If this is need it should never influence the implementation of the bind mixin






$bind-validation
Can be used to create a validation summary or custom interaction like tooltip






$aria-current-page=”boolean”






$aria-expanded
















Inject Style Tag


<style as=”inject-style” inject-query=”csb-a, csb-b” inject-auto=”csb-*”>
        :host { outline: 1px solid red; }
</style>


<link as="inject-link" rel="stylesheet" href="styles.css" inject-query=”csb-a, csb-b”>



The order of mixin attributes should not make a difference:



 








Phases
Parse: HTML Dom -> Json
Glob: Match string to glob *-test  Alternative: el in -> Attribute object and helper functions
Define: Define component
Attr: Bind properties + listeners
Array: Template DOM Nodes are rendered from virtual array








$else $if=”test” $repeat=”array”








TODO
* store prop listen paths
* context passed
* else



Prototyp
Example 1


<btld-web-component tag="abc-simple">
        <attr name="var1" default="a"></attr>
        <template>
<div style="border: 1px solid red;">Test ${var1}</div>
</template>
</btld-web-component>



Alternative tags
btld-v1
btld-template
btld-define
btld-tag
btld-web
btld-html
btld-dom
btld-web-component


Tag lines:




Define web components in plain html. No compiler needed and it's usable with all popular frameworks and build systems. Also it's tiny and fast. 


Example 2


<btld-1 name="abc-test">
        
<attr name="var1" default="a"></attr>
<attr name="var2" split=","></attr>


<init load-user="user"></init>


<template>
        <div i18n-component="test" format-uppercase>
                <a href="#${var1}" $var1="var1">
                        Link ${var1} ${var2/0}
                </a>
                <span i18n="key1">
fallback ${user/name}
</span>
<a href="${i18n/key3}">Test</a>
        </div>
</template>


<template $if="var1" $repeat="var2">
        <li dynamic-tag="abc-${item}">${index}</li>
</template>


</btld-1>


<abc-test var1="--" var2="a,b,c,d"></abc-test>
<abc-test></abc-test>



setTimeout(function () {
        btld.i18n({
                test: {
                        key1: 'actual ${user/name} ${user/email}',
                        key2: '<a href="${i18n/key3}">Test</a>',
                        key3: '/test/'
                }
});
}, 2000);


btld.mixins['load-user'] = [1, (definition, vdom) => {
        UserService.load().then( user => vdom.setData({user}) );
}];



Todos initial rendering phase
* Add function to create components dynamically - 18 Zeilen ohne Caching
* Wait for dom to read out children -> definition structure - 19 Zeilen + 8 Zeilen ?
* Define VDom Classes: + local state and data change listeners even for arrays
* BtldVdomText (can contain placeholders)
* Execute / Sort mixins for entry nodes
* Define the function that is executed for every entry node
* Define the function that is executed for every text node rendering




Todos update rendering phase
* 



Todos Snippets


function getHTMLElement(tag) /*: new () => HTMLElement*/ {
    if (!tag) return HTMLElement;
    const upper = tag.charAt(0).toUpperCase() + tag.slice(1);
    const possible = window['HTML' + upper + 'Element'];
    if (possible && possible.DOCUMENT_NODE) return possible;
    return document.createElement(tag).constructor;
}


function define(tag, extend, prototype) {
    const ExtendClass = getHTMLElement(extend) ;
    const BtldWrapper = function() {
            let result = Reflect.construct(ExtendClass, [], new.target);
            if (result.init) result.init();
            return result;
    }
    Object.assign(BtldWrapper.prototype, prototype);
    Object.setPrototypeOf(BtldWrapper.prototype, ExtendClass.prototype);
    customElements.define(tag, BtldWrapper, extend ? {extends: extend} : {});
}

function ready(fn) {
  if (document.readyState !== 'loading') {
    fn();
    return;
  }
  document.addEventListener('DOMContentLoaded', fn);
}

// document.body.setAttribute('test', '123')
// boolean attribute uses empty string
// Want an object use: Object.fromEntries(attrs)


el.childNodes.forEach(node => {
let nodeType = node.nodeType;
        if (nodeType === 1) { // Node.ELEMENT_NODE
                let el = node as Element;
                let tag = el.tagName.toLowerCase();
                let attrs = Array.from(el.attributes).map(a => [a.name, a.value]);
                
        } else if (nodeType === 3) { // Node.TEXT_NODE
                let text = (node as Text).textContent;
                
}
});

type DataListener = (localState: any, propState: any) => void;


export class BtldVdomElement {
        detachedByMixin: {[mixin: string]: boolean} = {};
        renderedByMixin: string; // Mixin in conroll of this children array
children: BtldVdomElement[] = [];
        
        localState: {[key: string]: unknown};
        dataListeners: {order: number, listener: DataListener}[]
}


export class BtldVdomText extends BtldVdomElement {


}

type BtldCurrent = { node: BtldVdom, root: BtldVdom, mixin: string };


export function BtldVdom(current: BtldCurrent) {


        let renderedByMixin: string?;
        let children: BtldVdom[];
        let tag: string;
let synchronizeRender: boolean?;
let dom: HTMLElement;


        function runRenderer(func) {
                let builder = { tag, children };
                func(builder);
                tag = builder.tag;
                children = [...builder.children];
                synchronizeRender = true;


                // TODO directly make dom changes
                // Use replaceChildren  to render into dom
}


        this.render = function (func) {
                if (!renderedByMixin) renderedByMixin = current.mixin;
                if (func && renderedByMixin === current.mixin) runRenderer(func);
        };


        const detachedByMixin: {[mixin: string]: boolean} = {};
const dataListeners: {order: number, listener: DataListener}[] = [];
        
        this.detach = function (detached: boolean = true) {
                detachedByMixin[current.mixin] = detached;
}


let localState: {[key: string]: unknown};


this.setState = function (key: string, state: unknown) {
        (localState = localState || {})[key] = state;
};


this.getDom = function () {
        if (tag) return [dom || (dom = document.createElement(tag))];
        return this.children.flatMap(c => c && c.getDom());
};


this.synchronizeDom = function () {
        
        
};




};
